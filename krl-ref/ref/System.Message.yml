description: |
  Programming messages in KRL.

comments: |

  Message programming properties :

    * The message mechanism is reentrant, i.e. it can be started more than once at the same time.
    * Up to 3 parameters can be integrated into a message.
    * Generated messages are stored in a message buffer until they are deleted.
      Notification messages are not managed in the message buffer (“fire and forget” principle).
    * The messages can be easily checked or deleted. It is of no importance what order the messages were generated in or whether there are other messages present.
      Notification messages cannot be checked and cannot be deleted by means of a KRL instruction.

enums:
  - name: EKrlMsgType
    data-type: ENUM
    description: Message types
    comments: |
    values:
      - name: NOTIFY
        description: Notification message
      - name: STATE
        description: Status message
      - name: QUIT
        description: Acknowledgment message
      - name: WAITING
        description: Wait message
      - name: DIALOG
        description: End of program reached
  - name: KrlMsgParType_T
    data-type: ENUM
    description: Message parameter types
    comments: |
    values:
      - name: VALUE
        description: The parameter is inserted into the message text as specified in text, int, real or bool.
      - name: KEY
        description: The parameter is a key that must be searched for in the message database.
      - name: EMPTY
        description: The parameter is empty.
  - name: MsgBufMsgType_T
    data-type: ENUM
    description: Message parameter types
    comments: |
    values:
      - name: SYS_QUIT
        description: Acknowledgement messages from the kernel system
      - name: SYS_STATE
        description: Status messages from the kernel system
      - name: USR_QUIT
        description: User-defined acknowledgement messages
      - name: USR_WAIT
        description: User-defined wait messages
      - name: USR_STATE
        description: User-defined status messages
      - name: USR_DLG
        description: User-defined dialog messages
strucs:
  - name: KrlMsg_T
    data-type: STRUC
    description: Message data structure
    fields:
      - name: Modul[]
        data-type: CHAR[24]
        description: Originator displayed in the message window.
      - name: Nr
        data-type: INT
        description: Message number. Message numbers may be used more than once.
      - name: Msg_Txt[]
        data-type: CHAR[80]
        description: Message text (or key for a message database).
  - name: KrlMsgDlgSK_T
    data-type: STRUC
    description: Softkey data structure for dialog message
    fields:
      - name: Sk_Type
        data-type: KrlMsgParType_T
        description: The type of the softkey.
      - name: Sk_Txt
        data-type: CHAR[10]
        description: Label of the softkey (or key for a message database).
  - name: KrlMsgOpt_T
    data-type: STRUC
    description: Message options data structure
    fields:
      - name: Vl_Stop
        data-type: BOOL
        description: |
          If `true` `Set_KrlMsg()` or `Set_KrlDlg()` trigger an `ADVANCE` run stop.
          Default to `true`.
      - name: Clear_P_Reset
        data-type: BOOL
        description: |
          If `true` delete messages when the program is reset or deselected.
          In that case, all status messages, acknowledgement messages and wait messages generated by `Set_KrlMsg()` with the variable options are deleted.

          Notification messages can only be deleted using the softkeys Ackn. and Ackn. All. 
          For dialog messages `Clear_P_Reset` si always set to `true`.
      - name: Clear_P_Saw
        data-type: BOOL
        description: |
          Delete message when a block selection is carried out using the softkey `Line Sel`.
          If `true` all status messages, acknowledgement messages and wait messages generated by `Set_KrlMsg()` with the variable options are deleted.
          Default to `false`.

          Notification messages can only be deleted using the softkeys Ackn. and Ackn. All. 
          For dialog messages no block selection is possible while a dialog is present on the KUKA.HMI, as all operator control elements are deactivated.
      - name: Log_To_DB
        data-type: BOOL
        description: If `true` the message is logged. Default to `false`.
  - name: KrlMsgPar_T
    data-type: STRUC
    description: Message parameter data structure
    fields:
      - name: Par_Type
        data-type: KrlMsgParType_T
        description: Type of parameter.
      - name: Par_Txt[]
        data-type: CHAR[26]
        description: Text of the parameter (or key for a message database).
      - name: Par_Int
        data-type: INT
        description: This can be used to fill the placeholder with an integer value. It can only be used in conjunction with type=#value.
      - name: Par_Real
        data-type: REAL
        description: This can be used to fill the placeholder with a real value. It can only be used in conjunction with type=#value.
      - name: Par_Bool
        data-type: BOOL
        description: This can be used to fill the placeholder with a Boolean value. It can only be used in conjunction with type=#value.
  - name: MsgBuf_T
    data-type: STRUC
    description: Message buffer data structure
    comments: |
      Array of buffer elements containing all the messages in the buffer. 
      The array is filled in ascending order, without gaps, starting with `Index = 1`. 
      
      If there are fewer messages in the buffer than represented by the size of the array, these array elements are not initialized.
    fields:
      - name: Type
        data-type: MsgBufMsgType_T
        description: Message type.
      - name: Nr
        data-type: INT
        description: Message number.
      - name: Modul[]
        data-type: CHAR[24]
        description: |
          Represents the originator of the message.
          Only initialized for messages of type `#usr_...`, because with type `#sys_...` the parameter is usually a database key that cannot be used by the user. 
      - name: Msg_Txt[]
        data-type: CHAR[80]
        description: |
          Message text or message database key.
          Only initialized for messages of type `#usr_...`, because with type `#sys_...` the parameter is usually a database key that cannot be used by the user. 
      - name: Par_Type1
        data-type: KrlMsgParType_T
        description: Parameter type.
      - name: Par_Txt1[]
        data-type: CHAR[40]
        description: Text or database key of the parameter.
      - name: Par_Type2
        data-type: KrlMsgParType_T
        description: Parameter type.
      - name: Par_Txt2[]
        data-type: CHAR[40]
        description: Text or database key of the parameter.
      - name: Par_Type2
        data-type: KrlMsgParType_T
        description: Parameter type.
      - name: Par_Txt2[]
        data-type: CHAR[40]
        description: Text or database key of the parameter.
      - name: Handle
        data-type: INT
        description: internal handle for this message (only initialized for user-defined messages).        
variables:
functions:

  - name: Set_KrlMsg
    description: Generate a message.
    parameters:
      - name: type
        pass: IN
        type: EKrlMsgType
        description: Defines the type of the message to be generated (`#notify`, `#state`, `#quit`, `#waiting`).
      - name: msg
        pass: OUT
        type: KrlMsg_T
        description:  Structure defining the name, originator and message text
      - name: params
        pass: OUT
        type: KrlMsgPar_T
        description:  Structure containing the message parameters
      - name: options
        pass: OUT
        type: KrlMsgOpt_T
        description:  Structure containing the message reaction
    return-type: INT
    return-description: Returns a handle to the generated message. `handle > 0` on success, `handle = -1`on failure.
    comments: |
      The function Set_KrlMsg() generates a message. 
      This means that the message is transferred to the message buffer and displayed from there in the message window.
      
      *Return*

        * `-1`: The message could not be generated (e.g.because the message buffer is too full).
        * `>0`: The message was generated successfully.

      The return value is a valid handle that can be used for further operations for this message, e.g. for deleting the message with `Clear_KrlMsg()`.
      No handle is required for notification messages.

      *Exceptions*

        * Notification messages are displayed in the message window by means of Set_KrlMsg(). They are not managed in the message buffer, however (“fire and forget” principle).
        * To generate dialog messages, the function Set_KrlDlg() must be used.

  - name: Exists_KrlMsg
    description: Checks whether a specific message still exists.
    parameters:
      - name: handle
        pass: IN
        type: INT
        description: The handle provided for the message by the function `Set_KrlMsg()`.
    return-type: BOOL
    return-description: Returns `true` if the message still exists in the message buffer.
    comments: |
      The function `Exists_KrlMsg()` can be used to check whether a specific message still exists. 
      It also checks whether this message is still present in the message buffer.
      This means that the message is transferred to the message buffer and displayed from there in the message window.
      
      The function does not wait until the message has been deleted, but merely searches the buffer for the message with this handle.
      The KRL program must therefore be polled cyclically until the message has been deleted.

      Notification messages cannot be checked, as they are not managed in the message buffer.    

  - name: Clear_KrlMsg
    description: Delete a a specific message.
    parameters:
      - name: handle
        pass: IN
        type: INT
        description: |
          The handle of the message to delete. This handle is returned by the function `Set_KrlMsg()`.
    return-type: BOOL
    return-description: |
      * `true` if the message was sucessfully deleted.
      * `false` otherwise
    comments: |
      The function `Clear_KrlMsg()` can be used to delete a message. 
      This means that the message is removed from the message buffer and the message window.

      Notification messages cannot be deleted in this way, as they are not managed in the message buffer. 
      Notification messages can only be deleted via the KUKA.HMI using the softkeys Ackn. and Ackn. All.

        * `-1` : all messages initiated by this process are deleted.
        * `-99`: all user-defined messages are deleted (for all processes: `ROBOT`, `SUBMIT` and `COMMAND` interpreters).

  - name: Set_KrlDlg
    description: Generates a dialog message.
    parameters:
      - name: msg
        pass: OUT
        type: KrlMsg_T
        description: Structure defining the name, originator and message text.
      - name: params
        pass: OUT
        type: KrlMsgPar_T
        description: Structure containing the message parameters.
      - name: softkey
        pass: OUT
        type: KrlMsgDlgSK_T
        description: Structure containing the softkey assignment.
      - name: options
        pass: OUT
        type: KrlMsgOpt_T
        description: Structure containing the message reaction.
    return-type: INT
    return-description: |
      Returns a handle to the generated dialog message.

        - `handle > 0` on success
        - `handle = -1` on failure

    comments: |
      The function `Set_KrlDlg()` generates a dialog message.
      This means that the message is transferred to the message buffer and displayed from there in the message window.

      The function merely generates the dialog. It does not wait until the dialog has been answered. A dialog cannot be generated until no other dialog is active.

  - name: Exists_KrlDlg
    description: Checks whether a specific dialog message still exists.
    parameters:
      - name: handle
        pass: IN
        type: INT
        description: The handle provided for the dialog message by the function `Set_KrlDlg()`.
      - name: answer
        pass: OUT
        type: INT
        description: Number `1..7` of the softkey used to answer the dialog. `0` if the dialog was deleted before answering.
    return-type: BOOL
    return-description: |
      * `true` if the dialog message still exists in the message buffer.
      * `false` if the dialog message no longer exists in the message buffer and has therefore been answered
    comments: |
      The function `Exists_KrlDlg()` can be used to check whether a specific dialog still exists. 
      It also checks whether this dialog is still present in the message buffer.
      
      The function does not wait until the dialog has been deleted, but merely searches the buffer for the dialog with this handle. 
      The KRL program must therefore be polled cyclically until the dialog has been answered or deleted.

      *Returns*

        * `1..7` : answer with the corresponding softkey.
        * `0` : the dialog has not been answered,but deleted (e.g. the dialog has been deleted by means of `Clear_KrlMsg()` by an interrupt or by a different process).

  - name: Get_MsgBuffer
    description: Copy the content of the message buffer.
    parameters:
      - name: msgBuf[]
        pass: OUT
        type: MsgBuf_T[100]
        description: Array of buffer elements containing all the messages in the buffer
    return-type: INT
    return-description: Returns the number of messages in the message buffer.
    comments: |
      The function `Get_MsgBuffer()` reads the message buffer and writes the messages in the buffer to the `OUT` parameter `msgBuff[]`.
      The size of the buffer is `100`.

     
      `Get_MsgBuffer()` can read the following message types from the buffer :
      
        * Status messages from the kernel system (#sys_state)
        * Acknowledgement messages from the kernel system (#sys_quit)
        * User-defined status messages (#usr_state)
        * User-defined acknowledgement messages (#usr_quit)
        * User-defined dialog messages (#usr_dlg)
        * User-defined wait messages (#usr_wait)
