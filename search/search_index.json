{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to OpenKuka \u00b6 This website is a community effort to offers meaningful documentation for KUKA robots. While KUKA robots are powerful, the docs they provide to their customers is generally crappy and opaque. Getting Started \u00b6 For now have a taste by looking at the language ref section : System.Variables System.Messages Collaborate \u00b6 Comments, suggestions and contributions are really welcome. Please feel free to open issues on the github repo if you whish to collaborate. Info Language Reference doc is based on set of simple YAML files describing types , variables and functions . The data is passed to the site generator through a small python script and shaped thanks to jinja2 templates . Anyone should be able to write/enrich the YAML files describing the KRL language. Documentation on this topic coming soon ...","title":"Home"},{"location":"#welcome-to-openkuka","text":"This website is a community effort to offers meaningful documentation for KUKA robots. While KUKA robots are powerful, the docs they provide to their customers is generally crappy and opaque.","title":"Welcome to OpenKuka"},{"location":"#getting-started","text":"For now have a taste by looking at the language ref section : System.Variables System.Messages","title":"Getting Started"},{"location":"#collaborate","text":"Comments, suggestions and contributions are really welcome. Please feel free to open issues on the github repo if you whish to collaborate. Info Language Reference doc is based on set of simple YAML files describing types , variables and functions . The data is passed to the site generator through a small python script and shaped thanks to jinja2 templates . Anyone should be able to write/enrich the YAML files describing the KRL language. Documentation on this topic coming soon ...","title":"Collaborate"},{"location":"krl-ref/System.Functions/","text":"","title":"System.Functions"},{"location":"krl-ref/System.MachineData/","text":"","title":"System.MachineData"},{"location":"krl-ref/System.Message/","text":"System.Message Programming messages in KRL. Enum Types \u00b6 EKrlMsgType \u00b6 Message types Name Type EKrlMsgType ENUM Value Description #NOTIFY Notification message #STATE Status message #QUIT Acknowledgment message #WAITING Wait message #DIALOG End of program reached KrlMsgParType_T \u00b6 Message parameter types Name Type KrlMsgParType_T ENUM Value Description #VALUE The parameter is inserted into the message text as specified in text, int, real or bool. #KEY The parameter is a key that must be searched for in the message database. #EMPTY The parameter is empty. MsgBufMsgType_T \u00b6 Message parameter types Name Type MsgBufMsgType_T ENUM Value Description #SYS_QUIT Acknowledgement messages from the kernel system #SYS_STATE Status messages from the kernel system #USR_QUIT User-defined acknowledgement messages #USR_WAIT User-defined wait messages #USR_STATE User-defined status messages #USR_DLG User-defined dialog messages Struc Types \u00b6 KrlMsg_T \u00b6 Message data structure Name Type KrlMsg_T STRUC Field Type Description Modul[] CHAR[24] Originator displayed in the message window. Nr INT Message number. Message numbers may be used more than once. Msg_Txt[] CHAR[80] Message text (or key for a message database). KrlMsgDlgSK_T \u00b6 Softkey data structure for dialog message Name Type KrlMsgDlgSK_T STRUC Field Type Description Sk_Type KrlMsgParType_T The type of the softkey. Sk_Txt CHAR[10] Label of the softkey (or key for a message database). KrlMsgOpt_T \u00b6 Message options data structure Name Type KrlMsgOpt_T STRUC Field Type Description Vl_Stop BOOL If true Set_KrlMsg() or Set_KrlDlg() trigger an ADVANCE run stop. Default to true . Clear_P_Reset BOOL If true delete messages when the program is reset or deselected. In that case, all status messages, acknowledgement messages and wait messages generated by Set_KrlMsg() with the variable options are deleted. Notification messages can only be deleted using the softkeys Ackn. and Ackn. All. For dialog messages Clear_P_Reset si always set to true . Clear_P_Saw BOOL Delete message when a block selection is carried out using the softkey Line Sel . If true all status messages, acknowledgement messages and wait messages generated by Set_KrlMsg() with the variable options are deleted. Default to false . Notification messages can only be deleted using the softkeys Ackn. and Ackn. All. For dialog messages no block selection is possible while a dialog is present on the KUKA.HMI, as all operator control elements are deactivated. Log_To_DB BOOL If true the message is logged. Default to false . KrlMsgPar_T \u00b6 Message parameter data structure Name Type KrlMsgPar_T STRUC Field Type Description Par_Type KrlMsgParType_T Type of parameter. Par_Txt[] CHAR[26] Text of the parameter (or key for a message database). Par_Int INT This can be used to fill the placeholder with an integer value. It can only be used in conjunction with type=#value. Par_Real REAL This can be used to fill the placeholder with a real value. It can only be used in conjunction with type=#value. Par_Bool BOOL This can be used to fill the placeholder with a Boolean value. It can only be used in conjunction with type=#value. MsgBuf_T \u00b6 Message buffer data structure Name Type MsgBuf_T STRUC Field Type Description Type MsgBufMsgType_T Message type. Nr INT Message number. Modul[] CHAR[24] Represents the originator of the message. Only initialized for messages of type #usr_... , because with type #sys_... the parameter is usually a database key that cannot be used by the user. Msg_Txt[] CHAR[80] Message text or message database key. Only initialized for messages of type #usr_... , because with type #sys_... the parameter is usually a database key that cannot be used by the user. Par_Type1 KrlMsgParType_T Parameter type. Par_Txt1[] CHAR[40] Text or database key of the parameter. Par_Type2 KrlMsgParType_T Parameter type. Par_Txt2[] CHAR[40] Text or database key of the parameter. Par_Type2 KrlMsgParType_T Parameter type. Par_Txt2[] CHAR[40] Text or database key of the parameter. Handle INT internal handle for this message (only initialized for user-defined messages). Comments ... Notes Array of buffer elements containing all the messages in the buffer. The array is filled in ascending order, without gaps, starting with Index = 1 . If there are fewer messages in the buffer than represented by the size of the array, these array elements are not initialized. Functions \u00b6 Clear_KrlMsg \u00b6 Delete a a specific message. Parameters Parameter Type Value/Ref Description handle INT IN The handle of the message to delete. This handle is returned by the function Set_KrlMsg() . Return Type Description BOOL true if the message was sucessfully deleted. false otherwise Comments ... Notes The function Clear_KrlMsg() can be used to delete a message. This means that the message is removed from the message buffer and the message window. Notification messages cannot be deleted in this way, as they are not managed in the message buffer. Notification messages can only be deleted via the KUKA.HMI using the softkeys Ackn. and Ackn. All. -1 : all messages initiated by this process are deleted. -99 : all user-defined messages are deleted (for all processes: ROBOT , SUBMIT and COMMAND interpreters). Exists_KrlDlg \u00b6 Checks whether a specific dialog message still exists. Parameters Parameter Type Value/Ref Description handle INT IN The handle provided for the dialog message by the function Set_KrlDlg() . answer INT OUT Number 1..7 of the softkey used to answer the dialog. 0 if the dialog was deleted before answering. Return Type Description BOOL true if the dialog message still exists in the message buffer. false if the dialog message no longer exists in the message buffer and has therefore been answered Comments ... Notes The function Exists_KrlDlg() can be used to check whether a specific dialog still exists. It also checks whether this dialog is still present in the message buffer. The function does not wait until the dialog has been deleted, but merely searches the buffer for the dialog with this handle. The KRL program must therefore be polled cyclically until the dialog has been answered or deleted. Returns 1..7 : answer with the corresponding softkey. 0 : the dialog has not been answered,but deleted (e.g. the dialog has been deleted by means of Clear_KrlMsg() by an interrupt or by a different process). Exists_KrlMsg \u00b6 Checks whether a specific message still exists. Parameters Parameter Type Value/Ref Description handle INT IN The handle provided for the message by the function Set_KrlMsg() . Return Type Description BOOL Returns true if the message still exists in the message buffer. Comments ... Notes The function Exists_KrlMsg() can be used to check whether a specific message still exists. It also checks whether this message is still present in the message buffer. This means that the message is transferred to the message buffer and displayed from there in the message window. The function does not wait until the message has been deleted, but merely searches the buffer for the message with this handle. The KRL program must therefore be polled cyclically until the message has been deleted. Notification messages cannot be checked, as they are not managed in the message buffer. Get_MsgBuffer \u00b6 Copy the content of the message buffer. Parameters Parameter Type Value/Ref Description msgBuf[] MsgBuf_T [100] OUT Array of buffer elements containing all the messages in the buffer Return Type Description INT Returns the number of messages in the message buffer. Comments ... Notes The function Get_MsgBuffer() reads the message buffer and writes the messages in the buffer to the OUT parameter msgBuff[] . The size of the buffer is 100 . Get_MsgBuffer() can read the following message types from the buffer : Status messages from the kernel system (#sys_state) Acknowledgement messages from the kernel system (#sys_quit) User-defined status messages (#usr_state) User-defined acknowledgement messages (#usr_quit) User-defined dialog messages (#usr_dlg) User-defined wait messages (#usr_wait) Set_KrlDlg \u00b6 Generates a dialog message. Parameters Parameter Type Value/Ref Description msg KrlMsg_T OUT Structure defining the name, originator and message text. params KrlMsgPar_T OUT Structure containing the message parameters. softkey KrlMsgDlgSK_T OUT Structure containing the softkey assignment. options KrlMsgOpt_T OUT Structure containing the message reaction. Return Type Description INT Returns a handle to the generated dialog message. handle > 0 on success handle = -1 on failure Comments ... Notes The function Set_KrlDlg() generates a dialog message. This means that the message is transferred to the message buffer and displayed from there in the message window. The function merely generates the dialog. It does not wait until the dialog has been answered. A dialog cannot be generated until no other dialog is active. Set_KrlMsg \u00b6 Generate a message. Parameters Parameter Type Value/Ref Description type EKrlMsgType IN Defines the type of the message to be generated ( #notify , #state , #quit , #waiting ). msg KrlMsg_T OUT Structure defining the name, originator and message text params KrlMsgPar_T OUT Structure containing the message parameters options KrlMsgOpt_T OUT Structure containing the message reaction Return Type Description INT Returns a handle to the generated message. handle > 0 on success, handle = -1 on failure. Comments ... Notes The function Set_KrlMsg() generates a message. This means that the message is transferred to the message buffer and displayed from there in the message window. Return -1 : The message could not be generated (e.g.because the message buffer is too full). >0 : The message was generated successfully. The return value is a valid handle that can be used for further operations for this message, e.g. for deleting the message with Clear_KrlMsg() . No handle is required for notification messages. Exceptions Notification messages are displayed in the message window by means of Set_KrlMsg(). They are not managed in the message buffer, however (\u201cfire and forget\u201d principle). To generate dialog messages, the function Set_KrlDlg() must be used. tippy('.tippy', { arrow: true, arrowType: 'sharp', // or 'sharp' (default) size: 'small', // \"small\", \"regular\", \"large\" interactive: true, })","title":"System.Message"},{"location":"krl-ref/System.Message/#enum-types","text":"","title":"Enum Types"},{"location":"krl-ref/System.Message/#ekrlmsgtype","text":"Message types Name Type EKrlMsgType ENUM Value Description #NOTIFY Notification message #STATE Status message #QUIT Acknowledgment message #WAITING Wait message #DIALOG End of program reached","title":"EKrlMsgType"},{"location":"krl-ref/System.Message/#krlmsgpartype_t","text":"Message parameter types Name Type KrlMsgParType_T ENUM Value Description #VALUE The parameter is inserted into the message text as specified in text, int, real or bool. #KEY The parameter is a key that must be searched for in the message database. #EMPTY The parameter is empty.","title":"KrlMsgParType_T"},{"location":"krl-ref/System.Message/#msgbufmsgtype_t","text":"Message parameter types Name Type MsgBufMsgType_T ENUM Value Description #SYS_QUIT Acknowledgement messages from the kernel system #SYS_STATE Status messages from the kernel system #USR_QUIT User-defined acknowledgement messages #USR_WAIT User-defined wait messages #USR_STATE User-defined status messages #USR_DLG User-defined dialog messages","title":"MsgBufMsgType_T"},{"location":"krl-ref/System.Message/#struc-types","text":"","title":"Struc Types"},{"location":"krl-ref/System.Message/#krlmsg_t","text":"Message data structure Name Type KrlMsg_T STRUC Field Type Description Modul[] CHAR[24] Originator displayed in the message window. Nr INT Message number. Message numbers may be used more than once. Msg_Txt[] CHAR[80] Message text (or key for a message database).","title":"KrlMsg_T"},{"location":"krl-ref/System.Message/#krlmsgdlgsk_t","text":"Softkey data structure for dialog message Name Type KrlMsgDlgSK_T STRUC Field Type Description Sk_Type KrlMsgParType_T The type of the softkey. Sk_Txt CHAR[10] Label of the softkey (or key for a message database).","title":"KrlMsgDlgSK_T"},{"location":"krl-ref/System.Message/#krlmsgopt_t","text":"Message options data structure Name Type KrlMsgOpt_T STRUC Field Type Description Vl_Stop BOOL If true Set_KrlMsg() or Set_KrlDlg() trigger an ADVANCE run stop. Default to true . Clear_P_Reset BOOL If true delete messages when the program is reset or deselected. In that case, all status messages, acknowledgement messages and wait messages generated by Set_KrlMsg() with the variable options are deleted. Notification messages can only be deleted using the softkeys Ackn. and Ackn. All. For dialog messages Clear_P_Reset si always set to true . Clear_P_Saw BOOL Delete message when a block selection is carried out using the softkey Line Sel . If true all status messages, acknowledgement messages and wait messages generated by Set_KrlMsg() with the variable options are deleted. Default to false . Notification messages can only be deleted using the softkeys Ackn. and Ackn. All. For dialog messages no block selection is possible while a dialog is present on the KUKA.HMI, as all operator control elements are deactivated. Log_To_DB BOOL If true the message is logged. Default to false .","title":"KrlMsgOpt_T"},{"location":"krl-ref/System.Message/#krlmsgpar_t","text":"Message parameter data structure Name Type KrlMsgPar_T STRUC Field Type Description Par_Type KrlMsgParType_T Type of parameter. Par_Txt[] CHAR[26] Text of the parameter (or key for a message database). Par_Int INT This can be used to fill the placeholder with an integer value. It can only be used in conjunction with type=#value. Par_Real REAL This can be used to fill the placeholder with a real value. It can only be used in conjunction with type=#value. Par_Bool BOOL This can be used to fill the placeholder with a Boolean value. It can only be used in conjunction with type=#value.","title":"KrlMsgPar_T"},{"location":"krl-ref/System.Message/#msgbuf_t","text":"Message buffer data structure Name Type MsgBuf_T STRUC Field Type Description Type MsgBufMsgType_T Message type. Nr INT Message number. Modul[] CHAR[24] Represents the originator of the message. Only initialized for messages of type #usr_... , because with type #sys_... the parameter is usually a database key that cannot be used by the user. Msg_Txt[] CHAR[80] Message text or message database key. Only initialized for messages of type #usr_... , because with type #sys_... the parameter is usually a database key that cannot be used by the user. Par_Type1 KrlMsgParType_T Parameter type. Par_Txt1[] CHAR[40] Text or database key of the parameter. Par_Type2 KrlMsgParType_T Parameter type. Par_Txt2[] CHAR[40] Text or database key of the parameter. Par_Type2 KrlMsgParType_T Parameter type. Par_Txt2[] CHAR[40] Text or database key of the parameter. Handle INT internal handle for this message (only initialized for user-defined messages). Comments ... Notes Array of buffer elements containing all the messages in the buffer. The array is filled in ascending order, without gaps, starting with Index = 1 . If there are fewer messages in the buffer than represented by the size of the array, these array elements are not initialized.","title":"MsgBuf_T"},{"location":"krl-ref/System.Message/#functions","text":"","title":"Functions"},{"location":"krl-ref/System.Message/#clear_krlmsg","text":"Delete a a specific message. Parameters Parameter Type Value/Ref Description handle INT IN The handle of the message to delete. This handle is returned by the function Set_KrlMsg() . Return Type Description BOOL true if the message was sucessfully deleted. false otherwise Comments ... Notes The function Clear_KrlMsg() can be used to delete a message. This means that the message is removed from the message buffer and the message window. Notification messages cannot be deleted in this way, as they are not managed in the message buffer. Notification messages can only be deleted via the KUKA.HMI using the softkeys Ackn. and Ackn. All. -1 : all messages initiated by this process are deleted. -99 : all user-defined messages are deleted (for all processes: ROBOT , SUBMIT and COMMAND interpreters).","title":"Clear_KrlMsg"},{"location":"krl-ref/System.Message/#exists_krldlg","text":"Checks whether a specific dialog message still exists. Parameters Parameter Type Value/Ref Description handle INT IN The handle provided for the dialog message by the function Set_KrlDlg() . answer INT OUT Number 1..7 of the softkey used to answer the dialog. 0 if the dialog was deleted before answering. Return Type Description BOOL true if the dialog message still exists in the message buffer. false if the dialog message no longer exists in the message buffer and has therefore been answered Comments ... Notes The function Exists_KrlDlg() can be used to check whether a specific dialog still exists. It also checks whether this dialog is still present in the message buffer. The function does not wait until the dialog has been deleted, but merely searches the buffer for the dialog with this handle. The KRL program must therefore be polled cyclically until the dialog has been answered or deleted. Returns 1..7 : answer with the corresponding softkey. 0 : the dialog has not been answered,but deleted (e.g. the dialog has been deleted by means of Clear_KrlMsg() by an interrupt or by a different process).","title":"Exists_KrlDlg"},{"location":"krl-ref/System.Message/#exists_krlmsg","text":"Checks whether a specific message still exists. Parameters Parameter Type Value/Ref Description handle INT IN The handle provided for the message by the function Set_KrlMsg() . Return Type Description BOOL Returns true if the message still exists in the message buffer. Comments ... Notes The function Exists_KrlMsg() can be used to check whether a specific message still exists. It also checks whether this message is still present in the message buffer. This means that the message is transferred to the message buffer and displayed from there in the message window. The function does not wait until the message has been deleted, but merely searches the buffer for the message with this handle. The KRL program must therefore be polled cyclically until the message has been deleted. Notification messages cannot be checked, as they are not managed in the message buffer.","title":"Exists_KrlMsg"},{"location":"krl-ref/System.Message/#get_msgbuffer","text":"Copy the content of the message buffer. Parameters Parameter Type Value/Ref Description msgBuf[] MsgBuf_T [100] OUT Array of buffer elements containing all the messages in the buffer Return Type Description INT Returns the number of messages in the message buffer. Comments ... Notes The function Get_MsgBuffer() reads the message buffer and writes the messages in the buffer to the OUT parameter msgBuff[] . The size of the buffer is 100 . Get_MsgBuffer() can read the following message types from the buffer : Status messages from the kernel system (#sys_state) Acknowledgement messages from the kernel system (#sys_quit) User-defined status messages (#usr_state) User-defined acknowledgement messages (#usr_quit) User-defined dialog messages (#usr_dlg) User-defined wait messages (#usr_wait)","title":"Get_MsgBuffer"},{"location":"krl-ref/System.Message/#set_krldlg","text":"Generates a dialog message. Parameters Parameter Type Value/Ref Description msg KrlMsg_T OUT Structure defining the name, originator and message text. params KrlMsgPar_T OUT Structure containing the message parameters. softkey KrlMsgDlgSK_T OUT Structure containing the softkey assignment. options KrlMsgOpt_T OUT Structure containing the message reaction. Return Type Description INT Returns a handle to the generated dialog message. handle > 0 on success handle = -1 on failure Comments ... Notes The function Set_KrlDlg() generates a dialog message. This means that the message is transferred to the message buffer and displayed from there in the message window. The function merely generates the dialog. It does not wait until the dialog has been answered. A dialog cannot be generated until no other dialog is active.","title":"Set_KrlDlg"},{"location":"krl-ref/System.Message/#set_krlmsg","text":"Generate a message. Parameters Parameter Type Value/Ref Description type EKrlMsgType IN Defines the type of the message to be generated ( #notify , #state , #quit , #waiting ). msg KrlMsg_T OUT Structure defining the name, originator and message text params KrlMsgPar_T OUT Structure containing the message parameters options KrlMsgOpt_T OUT Structure containing the message reaction Return Type Description INT Returns a handle to the generated message. handle > 0 on success, handle = -1 on failure. Comments ... Notes The function Set_KrlMsg() generates a message. This means that the message is transferred to the message buffer and displayed from there in the message window. Return -1 : The message could not be generated (e.g.because the message buffer is too full). >0 : The message was generated successfully. The return value is a valid handle that can be used for further operations for this message, e.g. for deleting the message with Clear_KrlMsg() . No handle is required for notification messages. Exceptions Notification messages are displayed in the message window by means of Set_KrlMsg(). They are not managed in the message buffer, however (\u201cfire and forget\u201d principle). To generate dialog messages, the function Set_KrlDlg() must be used. tippy('.tippy', { arrow: true, arrowType: 'sharp', // or 'sharp' (default) size: 'small', // \"small\", \"regular\", \"large\" interactive: true, })","title":"Set_KrlMsg"},{"location":"krl-ref/System.Types/","text":"","title":"System.Types"},{"location":"krl-ref/System.Variables/","text":"","title":"System.Variables"},{"location":"krl-ref/System/","text":"System Enum Types \u00b6 ADAP_ACC \u00b6 Acceleration adaptation modes Name Type ADAP_ACC ENUM Value Description #NONE Acceleration adaptation not activated #STEP1 Dynamic model without kinetic energy #STEP2 Dynamic model with kinetic energy PRO_MODE \u00b6 Program run modes Name Type PRO_MODE ENUM Value Description #ISTEP Incremental Step : block-by-block processing with a stop after each instruction (without ADVANCE run processing). #PSTEP Program Step: complete processing of subprograms (without ADVANCE run processing). #MSTEP Motion Step: step-by-step processing with a stop after each motion instruction (without ADVANCE run processing). #CSTEP Continuous Step: Step-by-step processing with a stop after each motion instruction (with ADVANCE run processing). #GO Continuous execution to the end of the program. #BSTEP Back Step: Continuous execution backwards to the start of the program. PRO_STATE \u00b6 Process states Name Type PRO_STATE ENUM Value Description #P_FREE Program not selected #P_RESET Program reset #P_ACTIVE Program active #P_STOP Program stopped #P_END End of program reached SW_ONOFF \u00b6 Generic ON/OFF switch Name Type SW_ONOFF ENUM Value Description #ON Switched ON #OFF Switched OFF Struc Types \u00b6 ACC_CAR \u00b6 Frame data structure with an additional magnitude field. Name Type ACC_CAR STRUC Field Type Description X REAL X component Y REAL X component Z REAL X component ABS REAL Magnitude ||X 2 + Y 2 + Z 2 || A REAL A component B REAL B component C REAL C component AXIS \u00b6 Robot axis A1..A6 data structure. Name Type AXIS STRUC Field Type Description A1 REAL A2 REAL A3 REAL A4 REAL A5 REAL A6 REAL CP \u00b6 Speed/Acceleration data structure Name Type CP STRUC Field Type Description CP REAL linear component ORI1 REAL Swivel component ORI2 REAL Rotational component E6AXIS \u00b6 Robot axis A1..A6 and external axis E1..E6 data structure. Name Type E6AXIS STRUC Field Type Description A1 REAL A2 REAL A3 REAL A4 REAL A5 REAL A6 REAL E1 REAL E2 REAL E3 REAL E4 REAL E5 REAL E6 REAL E6POS \u00b6 Position data structure. Name Type E6POS STRUC Field Type Description X REAL Y REAL Z REAL A REAL B REAL C REAL E1 REAL E2 REAL E3 REAL E4 REAL E5 REAL E6 REAL S INT Status T INT Turn FRAME \u00b6 Frame data structure. Name Type FRAME STRUC Field Type Description X REAL Y REAL Z REAL A REAL B REAL C REAL POS \u00b6 Position data structure. Name Type POS STRUC Field Type Description X REAL Y REAL Z REAL A REAL B REAL C REAL S INT Status T INT Turn PRO_IP \u00b6 Process pointer data structure Name Type PRO_IP STRUC Field Type Description I_EXECUTED BOOL true if the instruction is executed. false otherwise. NAME[] CHAR[32] Name of the block in the ADVANCE run NAME_C[] CHAR[32] Name of the block in the MAIN run P_ARRIVED INT Path status for the programmed point P_NAME[] CHAR[24] Name or aggregate of the end or auxiliary point SNR INT Block number in the ADVANCE run SNR_C INT Block number in the MAIN run SIGINF \u00b6 Signal info data structure. Name Type SIGINF STRUC Field Type Description Typ ENUM #IN : signal is declared for inputs #OUT : signal is declared for outputs #INV : signal is not declared #IN0 : reserved for future use #OUT0 : signal for system outputs set to false DTyp ENUM #SYSI : system signal of data type INT (whole number) #SYSB : system signal of data type BOOL (logic state) #USRI : user-defined global signal of data type INT #USRB : user-defined global signal of data type BOOL Idx INT Signal number. O for invalid signal or signal set to false . Len INT Signal length. 1 for signal of type BOOL . 0 for invalid signal. SIGNAL \u00b6 A signal defines and alias to one or several IN/OUT Name Type SIGNAL STRUC Comments ... Notes A SIGNAL links predefined signal variables for inputs or outputs with a name. Such a link, i.e. a SIGNAL declaration, is required in order to be able to address an analog input or output. An input or output may appear in several SIGNAL declarations. Variables \u00b6 $A4PAR \u00b6 Set axis 4 parallel to the last rotational main axis Name Type Unit Constraint $A4PAR INT 0 when unset. 1 when set $ABS_ACCUR \u00b6 Switch absolutely accurate robot model on/off Name Type $ABS_ACCUR BOOL $ABS_CONVERT \u00b6 Conversion of point coordinates into absolutely accurate robot model Name Type $ABS_CONVERT BOOL $ABS_RELOAD \u00b6 Reload absolutely accurate robot model Name Type $ABS_RELOAD BOOL $ACC \u00b6 Accelerations in the ADVANCE run Name Type $ACC CP Field Type Unit Constraint Description CP REAL m/s 2 Path acceleration in the ADVANCE run ORI1 REAL \u00b0/s 2 Swivel acceleration in the ADVANCE run ORI2 REAL \u00b0/s 2 Rotational acceleration in the ADVANCE run $ACC_ACT_MA \u00b6 Limit value of axial command acceleration Name Type Unit Constraint $ACC_ACT_MA INT % [0,100] $ACC_AXIS[] \u00b6 Acceleration of the axes A1..A6 in the ADVANCE run Name Type Unit Constraint $ACC_AXIS[] INT[6] % [0,100] $ACC_AXIS_C[] \u00b6 Acceleration of the axes A1..A6 in the MAIN run Name Type Unit Constraint $ACC_AXIS_C[] INT[6] % [0,100] $ACC_C \u00b6 Accelerations in the MAIN run Name Type $ACC_C CP Field Type Unit Constraint Description CP REAL m/s 2 > 0 Path acceleration in the MAIN run ORI1 REAL \u00b0/s 2 Swivel acceleration in the MAIN run ORI2 REAL \u00b0/s 2 Rotational acceleration in the MAIN run $ACC_CAR_ACT \u00b6 The current values of the acceleration components and the total acceleration Name Type $ACC_CAR_ACT ACC_CAR Field Type Unit Constraint Description X REAL m/s 2 X component of the acceleration expressed in $ACC_CAR_TOOL frame. Y REAL m/s 2 Y component of the acceleration expressed in $ACC_CAR_TOOL frame. Z REAL m/s 2 Z component of the acceleration expressed in $ACC_CAR_TOOL frame. ABS REAL m/s 2 >= 0 Acceleration magnitude. Comments ... Notes Acceleration due to gravity (9.81 m/s 2 ) is automatically calculated into the acceleration caused by the motion. Note that A , B and C fields are not used. $ACC_CAR_LIMIT \u00b6 Maximum permissible value for the acceleration components and the total acceleration Name Type $ACC_CAR_LIMIT ACC_CAR Field Type Unit Constraint Description X REAL m/s 2 Maximum permissible value for the X component of the acceleration expressed in $ACC_CAR_TOOL frame. Y REAL m/s 2 Maximum permissible value for the Y component of the acceleration expressed in $ACC_CAR_TOOL frame. Z REAL m/s 2 Maximum permissible value for the Z component of the acceleration expressed in $ACC_CAR_TOOL frame. ABS REAL m/s 2 >= 0 Maximum permissible value for the acceleration magnitude. Comments ... Notes If the variable $ACC_CAR_STOP is set to true , then if the acceleration value is exceeded the robot is stopped (ramp-down braking) and an acknowledgement message is generated. Note that A , B and C fields are not used. $ACC_CAR_MAX \u00b6 Saves the greatest absolute values of $ACC_CAR_ACT Name Type $ACC_CAR_MAX ACC_CAR Comments ... Notes This variable can be set to 0 to determine the maximum values. $ACC_CAR_STOP \u00b6 Activates/Deactivates stop reaction when the value specified in $ACC_CAR_LIMIT is exceeded. Name Type $ACC_CAR_STOP BOOL $ACC_CAR_TOOL \u00b6 A point on the tool mounted on the robot at which the current effective acceleration is measured Name Type $ACC_CAR_TOOL FRAME Comments ... Notes In the same way as $TOOL , $ACC_CAR_TOOL is also specified relative to the flange by means of the X , Y and Z coordinates. The angles of rotation A , B and C indicate the positions of the 3 axes of the coordinate system in which the acceleration components are then specified. The individual acceleration components and the total acceleration are all evaluated cyclically. Acceleration caused by gear unit torsion or flexion of the robot is not taken into consideration. $ACC_EXTAX[] \u00b6 Acceleration of the external axes E1..E7 in the ADVANCE run Name Type Unit Constraint $ACC_EXTAX[] INT[6] % [0,100] $ACC_EXTAX_C[] \u00b6 Acceleration of the external axes E1..E7 in the MAIN run Name Type Unit Constraint $ACC_EXTAX_C[] INT[6] % [0,100] $ACC_MA \u00b6 Maximum values for path, swivel and rotational accelerations Name Type $ACC_MA CP Field Type Unit Constraint Description CP REAL m/s 2 Maximum path acceleration ORI1 REAL \u00b0/s 2 Maximum swivel acceleration ORI2 REAL \u00b0/s 2 Maximum rotational acceleration $ACC_OV \u00b6 Data for acceleration with changes of override Name Type $ACC_OV CP Field Type Unit Constraint Description CP REAL m/s 2 Path acceleration with change of override ORI1 REAL \u00b0/s 2 Swivel acceleration with change of override ORI2 REAL \u00b0/s 2 Rotational acceleration with change of override $ACT_BASE \u00b6 Number of the current BASE system Name Type Unit Constraint $ACT_BASE INT index $ACT_EX_AX \u00b6 Number of the current external base kinematic system Name Type Unit Constraint $ACT_EX_AX INT index $ACT_TOOL \u00b6 Number of the current tool coordinate system Name Type Unit Constraint $ACT_TOOL INT index $ACT_VAL_DIF \u00b6 Maximum permissible difference of encoder actual values when switching on system. Name Type Unit Constraint $ACT_VAL_DIF INT increments Comments ... Notes If the limit values are exceeded, the message Perform mastering appears. $ADAP_ACC \u00b6 Activation of acceleration adaptation. Name Type Constraint $ADAP_ACC ADAP_ACC #NONE , #STEP1 , #STEP2 Comments ... Notes #STEP1 and #STEP2 require valid dynamic data ( $DYN_DAT ). $ADVANCE \u00b6 Specification of the ADVANCE run. Name Type Unit Constraint $ADVANCE INT motion blocks [0,5] $ALARM_STOP \u00b6 Specification of the ADVANCE run. Name Type $ALARM_STOP SIGNAL $ANA_DEL_FLT \u00b6 Analog output filter Name Type Constraint $ANA_DEL_FLT SW_ONOFF #ON , #OFF $ANIN[] \u00b6 Analog inputs $ANIN[1]..$ANIN[8] Name Type Unit Constraint $ANIN[] REAL[8] [-1.0, 1.0] Comments ... Notes -1.0 maps to -10V +1.0 maps to +10V $ANOUT[] \u00b6 Analog outputs $ANIN[1]..$ANIN[16] Name Type Unit Constraint $ANOUT[] REAL[16] [-1.0, 1.0] Comments ... Notes -1.0 maps to -10V +1.0 maps to +10V $APO_DIS_PTP[] \u00b6 Maximum approximation distance for PTP motions. Name Type Unit Constraint $APO_DIS_PTP[] REAL[12] mm or \u00b0 Comments ... Notes 1..6 : axis A1..A6 7..12 : external axis E1..E6 $ASYNC_AX \u00b6 Motion input for asynchronous external axes E1..E6 , negative or positive direction. Name Type $ASYNC_AX SIGNAL $ASYNC_AXi_M \u00b6 Motion input for asynchronous external axes E1..E6 , negative direction Name Type $ASYNC_AXi_M SIGNAL Comments ... Notes SIGNAL $ASYNC_AX1_M $IN[1026] SIGNAL $ASYNC_AX2_M $IN[1026] SIGNAL $ASYNC_AX3_M $IN[1026] SIGNAL $ASYNC_AX4_M $IN[1026] SIGNAL $ASYNC_AX5_M $IN[1026] SIGNAL $ASYNC_AX6_M $IN[1026] $ASYNC_AXi_P \u00b6 Motion input for asynchronous external axes E1..E6 , positive direction Name Type $ASYNC_AXi_P SIGNAL Comments ... Notes SIGNAL $ASYNC_AX1_P $IN[1026] SIGNAL $ASYNC_AX2_P $IN[1026] SIGNAL $ASYNC_AX3_P $IN[1026] SIGNAL $ASYNC_AX4_P $IN[1026] SIGNAL $ASYNC_AX5_P $IN[1026] SIGNAL $ASYNC_AX6_P $IN[1026] $OV_PRO \u00b6 Program override Name Type Unit Constraint $OV_PRO INT % [0, 100] Comments ... Notes Program override is the velocity of the robot during program execution. The program override is specified as a percentage of the programmed velocity. In T1 mode, the maximum velocity is 250 mm/s, irrespective of the value that is set. $PRO_MODE \u00b6 Program run mode dependent on $INTERPRETER Name Type Constraint $PRO_MODE PRO_MODE #ISTEP , #PSTEP , #MSTEP , #CSTEP , #GO , #BSTEP $PRO_MODE0 \u00b6 Program run mode of the SUBMIT interpreter Name Type Constraint $PRO_MODE0 PRO_MODE #ISTEP , #PSTEP , #MSTEP , #CSTEP , #GO , #BSTEP $PRO_MODE1 \u00b6 Program run mode of the ROBOT interpreter Name Type Constraint $PRO_MODE1 PRO_MODE #ISTEP , #PSTEP , #MSTEP , #CSTEP , #GO , #BSTEP $PRO_NAME0[] \u00b6 Process name of the SUBMIT interpreter Name Type $PRO_NAME0[] CHAR[24] $PRO_NAME1[] \u00b6 Process name of the ROBOT interpreter Name Type $PRO_NAME1[] CHAR[24] $PRO_NAME[] \u00b6 Process name dependent on $INTERPRETER Name Type $PRO_NAME[] CHAR[24] $PRO_STATE \u00b6 Process state dependent on $INTERPRETER Name Type Constraint $PRO_STATE PRO_STATE #P_FREE , #P_RESET , #P_ACTIVE , #P_STOP , #P_END $PRO_STATE0 \u00b6 Process state of the SUBMIT interpreter Name Type Constraint $PRO_STATE0 PRO_STATE #P_FREE , #P_RESET , #P_ACTIVE , #P_STOP , #P_END $PRO_STATE1 \u00b6 Process state of the ROBOT interpreter Name Type Constraint $PRO_STATE1 PRO_STATE #P_FREE , #P_RESET , #P_ACTIVE , #P_STOP , #P_END Functions \u00b6 StrCopy \u00b6 Copy the contents of a string variable to another string variable. Parameters Parameter Type Value/Ref Description strDest[] CHAR[] IN The character string is copied to this string variable. Since strDest[] is an array of type CHAR , individual characters and constants are not permissible. strSource[] CHAR[] IN The contents of this string variable are copied. Return Type Description BOOL Returns true if the copy was successfull. Returns false otherwise. Comments ... Notes The function StrCopy() can be used to copy the contents of a string variable to another string variable. Code Sample KRL 1 2 3 4 5 DECL CHAR A [ 25 ] , B [ 25 ] DECL BOOL C A [] = \"\" B [] = \" Example \" C = StrCopy ( A [] , B []) Output 1 2 A[] = \"Example\" and C = true tippy('.tippy', { arrow: true, arrowType: 'sharp', // or 'sharp' (default) size: 'small', // \"small\", \"regular\", \"large\" interactive: true, })","title":"System"},{"location":"krl-ref/System/#enum-types","text":"","title":"Enum Types"},{"location":"krl-ref/System/#adap_acc","text":"Acceleration adaptation modes Name Type ADAP_ACC ENUM Value Description #NONE Acceleration adaptation not activated #STEP1 Dynamic model without kinetic energy #STEP2 Dynamic model with kinetic energy","title":"ADAP_ACC"},{"location":"krl-ref/System/#pro_mode","text":"Program run modes Name Type PRO_MODE ENUM Value Description #ISTEP Incremental Step : block-by-block processing with a stop after each instruction (without ADVANCE run processing). #PSTEP Program Step: complete processing of subprograms (without ADVANCE run processing). #MSTEP Motion Step: step-by-step processing with a stop after each motion instruction (without ADVANCE run processing). #CSTEP Continuous Step: Step-by-step processing with a stop after each motion instruction (with ADVANCE run processing). #GO Continuous execution to the end of the program. #BSTEP Back Step: Continuous execution backwards to the start of the program.","title":"PRO_MODE"},{"location":"krl-ref/System/#pro_state","text":"Process states Name Type PRO_STATE ENUM Value Description #P_FREE Program not selected #P_RESET Program reset #P_ACTIVE Program active #P_STOP Program stopped #P_END End of program reached","title":"PRO_STATE"},{"location":"krl-ref/System/#sw_onoff","text":"Generic ON/OFF switch Name Type SW_ONOFF ENUM Value Description #ON Switched ON #OFF Switched OFF","title":"SW_ONOFF"},{"location":"krl-ref/System/#struc-types","text":"","title":"Struc Types"},{"location":"krl-ref/System/#acc_car","text":"Frame data structure with an additional magnitude field. Name Type ACC_CAR STRUC Field Type Description X REAL X component Y REAL X component Z REAL X component ABS REAL Magnitude ||X 2 + Y 2 + Z 2 || A REAL A component B REAL B component C REAL C component","title":"ACC_CAR"},{"location":"krl-ref/System/#axis","text":"Robot axis A1..A6 data structure. Name Type AXIS STRUC Field Type Description A1 REAL A2 REAL A3 REAL A4 REAL A5 REAL A6 REAL","title":"AXIS"},{"location":"krl-ref/System/#cp","text":"Speed/Acceleration data structure Name Type CP STRUC Field Type Description CP REAL linear component ORI1 REAL Swivel component ORI2 REAL Rotational component","title":"CP"},{"location":"krl-ref/System/#e6axis","text":"Robot axis A1..A6 and external axis E1..E6 data structure. Name Type E6AXIS STRUC Field Type Description A1 REAL A2 REAL A3 REAL A4 REAL A5 REAL A6 REAL E1 REAL E2 REAL E3 REAL E4 REAL E5 REAL E6 REAL","title":"E6AXIS"},{"location":"krl-ref/System/#e6pos","text":"Position data structure. Name Type E6POS STRUC Field Type Description X REAL Y REAL Z REAL A REAL B REAL C REAL E1 REAL E2 REAL E3 REAL E4 REAL E5 REAL E6 REAL S INT Status T INT Turn","title":"E6POS"},{"location":"krl-ref/System/#frame","text":"Frame data structure. Name Type FRAME STRUC Field Type Description X REAL Y REAL Z REAL A REAL B REAL C REAL","title":"FRAME"},{"location":"krl-ref/System/#pos","text":"Position data structure. Name Type POS STRUC Field Type Description X REAL Y REAL Z REAL A REAL B REAL C REAL S INT Status T INT Turn","title":"POS"},{"location":"krl-ref/System/#pro_ip","text":"Process pointer data structure Name Type PRO_IP STRUC Field Type Description I_EXECUTED BOOL true if the instruction is executed. false otherwise. NAME[] CHAR[32] Name of the block in the ADVANCE run NAME_C[] CHAR[32] Name of the block in the MAIN run P_ARRIVED INT Path status for the programmed point P_NAME[] CHAR[24] Name or aggregate of the end or auxiliary point SNR INT Block number in the ADVANCE run SNR_C INT Block number in the MAIN run","title":"PRO_IP"},{"location":"krl-ref/System/#siginf","text":"Signal info data structure. Name Type SIGINF STRUC Field Type Description Typ ENUM #IN : signal is declared for inputs #OUT : signal is declared for outputs #INV : signal is not declared #IN0 : reserved for future use #OUT0 : signal for system outputs set to false DTyp ENUM #SYSI : system signal of data type INT (whole number) #SYSB : system signal of data type BOOL (logic state) #USRI : user-defined global signal of data type INT #USRB : user-defined global signal of data type BOOL Idx INT Signal number. O for invalid signal or signal set to false . Len INT Signal length. 1 for signal of type BOOL . 0 for invalid signal.","title":"SIGINF"},{"location":"krl-ref/System/#signal","text":"A signal defines and alias to one or several IN/OUT Name Type SIGNAL STRUC Comments ... Notes A SIGNAL links predefined signal variables for inputs or outputs with a name. Such a link, i.e. a SIGNAL declaration, is required in order to be able to address an analog input or output. An input or output may appear in several SIGNAL declarations.","title":"SIGNAL"},{"location":"krl-ref/System/#variables","text":"","title":"Variables"},{"location":"krl-ref/System/#a4par","text":"Set axis 4 parallel to the last rotational main axis Name Type Unit Constraint $A4PAR INT 0 when unset. 1 when set","title":"$A4PAR"},{"location":"krl-ref/System/#abs_accur","text":"Switch absolutely accurate robot model on/off Name Type $ABS_ACCUR BOOL","title":"$ABS_ACCUR"},{"location":"krl-ref/System/#abs_convert","text":"Conversion of point coordinates into absolutely accurate robot model Name Type $ABS_CONVERT BOOL","title":"$ABS_CONVERT"},{"location":"krl-ref/System/#abs_reload","text":"Reload absolutely accurate robot model Name Type $ABS_RELOAD BOOL","title":"$ABS_RELOAD"},{"location":"krl-ref/System/#acc","text":"Accelerations in the ADVANCE run Name Type $ACC CP Field Type Unit Constraint Description CP REAL m/s 2 Path acceleration in the ADVANCE run ORI1 REAL \u00b0/s 2 Swivel acceleration in the ADVANCE run ORI2 REAL \u00b0/s 2 Rotational acceleration in the ADVANCE run","title":"$ACC"},{"location":"krl-ref/System/#acc_act_ma","text":"Limit value of axial command acceleration Name Type Unit Constraint $ACC_ACT_MA INT % [0,100]","title":"$ACC_ACT_MA"},{"location":"krl-ref/System/#acc_axis","text":"Acceleration of the axes A1..A6 in the ADVANCE run Name Type Unit Constraint $ACC_AXIS[] INT[6] % [0,100]","title":"$ACC_AXIS[]"},{"location":"krl-ref/System/#acc_axis_c","text":"Acceleration of the axes A1..A6 in the MAIN run Name Type Unit Constraint $ACC_AXIS_C[] INT[6] % [0,100]","title":"$ACC_AXIS_C[]"},{"location":"krl-ref/System/#acc_c","text":"Accelerations in the MAIN run Name Type $ACC_C CP Field Type Unit Constraint Description CP REAL m/s 2 > 0 Path acceleration in the MAIN run ORI1 REAL \u00b0/s 2 Swivel acceleration in the MAIN run ORI2 REAL \u00b0/s 2 Rotational acceleration in the MAIN run","title":"$ACC_C"},{"location":"krl-ref/System/#acc_car_act","text":"The current values of the acceleration components and the total acceleration Name Type $ACC_CAR_ACT ACC_CAR Field Type Unit Constraint Description X REAL m/s 2 X component of the acceleration expressed in $ACC_CAR_TOOL frame. Y REAL m/s 2 Y component of the acceleration expressed in $ACC_CAR_TOOL frame. Z REAL m/s 2 Z component of the acceleration expressed in $ACC_CAR_TOOL frame. ABS REAL m/s 2 >= 0 Acceleration magnitude. Comments ... Notes Acceleration due to gravity (9.81 m/s 2 ) is automatically calculated into the acceleration caused by the motion. Note that A , B and C fields are not used.","title":"$ACC_CAR_ACT"},{"location":"krl-ref/System/#acc_car_limit","text":"Maximum permissible value for the acceleration components and the total acceleration Name Type $ACC_CAR_LIMIT ACC_CAR Field Type Unit Constraint Description X REAL m/s 2 Maximum permissible value for the X component of the acceleration expressed in $ACC_CAR_TOOL frame. Y REAL m/s 2 Maximum permissible value for the Y component of the acceleration expressed in $ACC_CAR_TOOL frame. Z REAL m/s 2 Maximum permissible value for the Z component of the acceleration expressed in $ACC_CAR_TOOL frame. ABS REAL m/s 2 >= 0 Maximum permissible value for the acceleration magnitude. Comments ... Notes If the variable $ACC_CAR_STOP is set to true , then if the acceleration value is exceeded the robot is stopped (ramp-down braking) and an acknowledgement message is generated. Note that A , B and C fields are not used.","title":"$ACC_CAR_LIMIT"},{"location":"krl-ref/System/#acc_car_max","text":"Saves the greatest absolute values of $ACC_CAR_ACT Name Type $ACC_CAR_MAX ACC_CAR Comments ... Notes This variable can be set to 0 to determine the maximum values.","title":"$ACC_CAR_MAX"},{"location":"krl-ref/System/#acc_car_stop","text":"Activates/Deactivates stop reaction when the value specified in $ACC_CAR_LIMIT is exceeded. Name Type $ACC_CAR_STOP BOOL","title":"$ACC_CAR_STOP"},{"location":"krl-ref/System/#acc_car_tool","text":"A point on the tool mounted on the robot at which the current effective acceleration is measured Name Type $ACC_CAR_TOOL FRAME Comments ... Notes In the same way as $TOOL , $ACC_CAR_TOOL is also specified relative to the flange by means of the X , Y and Z coordinates. The angles of rotation A , B and C indicate the positions of the 3 axes of the coordinate system in which the acceleration components are then specified. The individual acceleration components and the total acceleration are all evaluated cyclically. Acceleration caused by gear unit torsion or flexion of the robot is not taken into consideration.","title":"$ACC_CAR_TOOL"},{"location":"krl-ref/System/#acc_extax","text":"Acceleration of the external axes E1..E7 in the ADVANCE run Name Type Unit Constraint $ACC_EXTAX[] INT[6] % [0,100]","title":"$ACC_EXTAX[]"},{"location":"krl-ref/System/#acc_extax_c","text":"Acceleration of the external axes E1..E7 in the MAIN run Name Type Unit Constraint $ACC_EXTAX_C[] INT[6] % [0,100]","title":"$ACC_EXTAX_C[]"},{"location":"krl-ref/System/#acc_ma","text":"Maximum values for path, swivel and rotational accelerations Name Type $ACC_MA CP Field Type Unit Constraint Description CP REAL m/s 2 Maximum path acceleration ORI1 REAL \u00b0/s 2 Maximum swivel acceleration ORI2 REAL \u00b0/s 2 Maximum rotational acceleration","title":"$ACC_MA"},{"location":"krl-ref/System/#acc_ov","text":"Data for acceleration with changes of override Name Type $ACC_OV CP Field Type Unit Constraint Description CP REAL m/s 2 Path acceleration with change of override ORI1 REAL \u00b0/s 2 Swivel acceleration with change of override ORI2 REAL \u00b0/s 2 Rotational acceleration with change of override","title":"$ACC_OV"},{"location":"krl-ref/System/#act_base","text":"Number of the current BASE system Name Type Unit Constraint $ACT_BASE INT index","title":"$ACT_BASE"},{"location":"krl-ref/System/#act_ex_ax","text":"Number of the current external base kinematic system Name Type Unit Constraint $ACT_EX_AX INT index","title":"$ACT_EX_AX"},{"location":"krl-ref/System/#act_tool","text":"Number of the current tool coordinate system Name Type Unit Constraint $ACT_TOOL INT index","title":"$ACT_TOOL"},{"location":"krl-ref/System/#act_val_dif","text":"Maximum permissible difference of encoder actual values when switching on system. Name Type Unit Constraint $ACT_VAL_DIF INT increments Comments ... Notes If the limit values are exceeded, the message Perform mastering appears.","title":"$ACT_VAL_DIF"},{"location":"krl-ref/System/#adap_acc_1","text":"Activation of acceleration adaptation. Name Type Constraint $ADAP_ACC ADAP_ACC #NONE , #STEP1 , #STEP2 Comments ... Notes #STEP1 and #STEP2 require valid dynamic data ( $DYN_DAT ).","title":"$ADAP_ACC"},{"location":"krl-ref/System/#advance","text":"Specification of the ADVANCE run. Name Type Unit Constraint $ADVANCE INT motion blocks [0,5]","title":"$ADVANCE"},{"location":"krl-ref/System/#alarm_stop","text":"Specification of the ADVANCE run. Name Type $ALARM_STOP SIGNAL","title":"$ALARM_STOP"},{"location":"krl-ref/System/#ana_del_flt","text":"Analog output filter Name Type Constraint $ANA_DEL_FLT SW_ONOFF #ON , #OFF","title":"$ANA_DEL_FLT"},{"location":"krl-ref/System/#anin","text":"Analog inputs $ANIN[1]..$ANIN[8] Name Type Unit Constraint $ANIN[] REAL[8] [-1.0, 1.0] Comments ... Notes -1.0 maps to -10V +1.0 maps to +10V","title":"$ANIN[]"},{"location":"krl-ref/System/#anout","text":"Analog outputs $ANIN[1]..$ANIN[16] Name Type Unit Constraint $ANOUT[] REAL[16] [-1.0, 1.0] Comments ... Notes -1.0 maps to -10V +1.0 maps to +10V","title":"$ANOUT[]"},{"location":"krl-ref/System/#apo_dis_ptp","text":"Maximum approximation distance for PTP motions. Name Type Unit Constraint $APO_DIS_PTP[] REAL[12] mm or \u00b0 Comments ... Notes 1..6 : axis A1..A6 7..12 : external axis E1..E6","title":"$APO_DIS_PTP[]"},{"location":"krl-ref/System/#async_ax","text":"Motion input for asynchronous external axes E1..E6 , negative or positive direction. Name Type $ASYNC_AX SIGNAL","title":"$ASYNC_AX"},{"location":"krl-ref/System/#async_axi_m","text":"Motion input for asynchronous external axes E1..E6 , negative direction Name Type $ASYNC_AXi_M SIGNAL Comments ... Notes SIGNAL $ASYNC_AX1_M $IN[1026] SIGNAL $ASYNC_AX2_M $IN[1026] SIGNAL $ASYNC_AX3_M $IN[1026] SIGNAL $ASYNC_AX4_M $IN[1026] SIGNAL $ASYNC_AX5_M $IN[1026] SIGNAL $ASYNC_AX6_M $IN[1026]","title":"$ASYNC_AXi_M"},{"location":"krl-ref/System/#async_axi_p","text":"Motion input for asynchronous external axes E1..E6 , positive direction Name Type $ASYNC_AXi_P SIGNAL Comments ... Notes SIGNAL $ASYNC_AX1_P $IN[1026] SIGNAL $ASYNC_AX2_P $IN[1026] SIGNAL $ASYNC_AX3_P $IN[1026] SIGNAL $ASYNC_AX4_P $IN[1026] SIGNAL $ASYNC_AX5_P $IN[1026] SIGNAL $ASYNC_AX6_P $IN[1026]","title":"$ASYNC_AXi_P"},{"location":"krl-ref/System/#ov_pro","text":"Program override Name Type Unit Constraint $OV_PRO INT % [0, 100] Comments ... Notes Program override is the velocity of the robot during program execution. The program override is specified as a percentage of the programmed velocity. In T1 mode, the maximum velocity is 250 mm/s, irrespective of the value that is set.","title":"$OV_PRO"},{"location":"krl-ref/System/#pro_mode_1","text":"Program run mode dependent on $INTERPRETER Name Type Constraint $PRO_MODE PRO_MODE #ISTEP , #PSTEP , #MSTEP , #CSTEP , #GO , #BSTEP","title":"$PRO_MODE"},{"location":"krl-ref/System/#pro_mode0","text":"Program run mode of the SUBMIT interpreter Name Type Constraint $PRO_MODE0 PRO_MODE #ISTEP , #PSTEP , #MSTEP , #CSTEP , #GO , #BSTEP","title":"$PRO_MODE0"},{"location":"krl-ref/System/#pro_mode1","text":"Program run mode of the ROBOT interpreter Name Type Constraint $PRO_MODE1 PRO_MODE #ISTEP , #PSTEP , #MSTEP , #CSTEP , #GO , #BSTEP","title":"$PRO_MODE1"},{"location":"krl-ref/System/#pro_name0","text":"Process name of the SUBMIT interpreter Name Type $PRO_NAME0[] CHAR[24]","title":"$PRO_NAME0[]"},{"location":"krl-ref/System/#pro_name1","text":"Process name of the ROBOT interpreter Name Type $PRO_NAME1[] CHAR[24]","title":"$PRO_NAME1[]"},{"location":"krl-ref/System/#pro_name","text":"Process name dependent on $INTERPRETER Name Type $PRO_NAME[] CHAR[24]","title":"$PRO_NAME[]"},{"location":"krl-ref/System/#pro_state_1","text":"Process state dependent on $INTERPRETER Name Type Constraint $PRO_STATE PRO_STATE #P_FREE , #P_RESET , #P_ACTIVE , #P_STOP , #P_END","title":"$PRO_STATE"},{"location":"krl-ref/System/#pro_state0","text":"Process state of the SUBMIT interpreter Name Type Constraint $PRO_STATE0 PRO_STATE #P_FREE , #P_RESET , #P_ACTIVE , #P_STOP , #P_END","title":"$PRO_STATE0"},{"location":"krl-ref/System/#pro_state1","text":"Process state of the ROBOT interpreter Name Type Constraint $PRO_STATE1 PRO_STATE #P_FREE , #P_RESET , #P_ACTIVE , #P_STOP , #P_END","title":"$PRO_STATE1"},{"location":"krl-ref/System/#functions","text":"","title":"Functions"},{"location":"krl-ref/System/#strcopy","text":"Copy the contents of a string variable to another string variable. Parameters Parameter Type Value/Ref Description strDest[] CHAR[] IN The character string is copied to this string variable. Since strDest[] is an array of type CHAR , individual characters and constants are not permissible. strSource[] CHAR[] IN The contents of this string variable are copied. Return Type Description BOOL Returns true if the copy was successfull. Returns false otherwise. Comments ... Notes The function StrCopy() can be used to copy the contents of a string variable to another string variable. Code Sample KRL 1 2 3 4 5 DECL CHAR A [ 25 ] , B [ 25 ] DECL BOOL C A [] = \"\" B [] = \" Example \" C = StrCopy ( A [] , B []) Output 1 2 A[] = \"Example\" and C = true tippy('.tippy', { arrow: true, arrowType: 'sharp', // or 'sharp' (default) size: 'small', // \"small\", \"regular\", \"large\" interactive: true, })","title":"StrCopy"}]}